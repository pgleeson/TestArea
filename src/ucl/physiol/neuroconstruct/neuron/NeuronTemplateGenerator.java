/**
 * neuroConstruct
 *
 * Software for developing large scale 3D networks of biologically realistic neurons
 * Copyright (c) 2007 Padraig Gleeson
 * UCL Department of Physiology
 *
 * Development of this software was made possible with funding from the
 * Medical Research Council
 *
 */

package ucl.physiol.neuroconstruct.neuron;

import java.io.*;
import java.util.*;

import javax.vecmath.*;

import ucl.physiol.neuroconstruct.cell.*;
import ucl.physiol.neuroconstruct.cell.utils.*;
import ucl.physiol.neuroconstruct.mechanisms.*;
import ucl.physiol.neuroconstruct.neuroml.*;
import ucl.physiol.neuroconstruct.project.*;
import ucl.physiol.neuroconstruct.utils.*;
import ucl.physiol.neuroconstruct.utils.units.*;
import ucl.physiol.neuroconstruct.utils.xml.*;

/**
 * Generates the hoc file for a specific cell template
 *
 * @author Padraig Gleeson
 * @version 1.0.4
 */

public class NeuronTemplateGenerator
{
    static ClassLogger logger = new ClassLogger("NeuronTemplateGenerator");

    Cell cell = null;

    Project project = null;

    File hocFile = null;

    // due to limitation in hoc interpreter, when too many lines are in a procedure
    int maxNumLinesInProc = 100;
    int numSegments = 1;

    boolean addGrowthFunctions = true;

    //Hashtable arrayNamesVsSections = new Hashtable();

    private NeuronTemplateGenerator()
    {
    }

    /**
     * Generates the HocTemplate for a single cell.
     * @param cell The Cell to generate for
     * @param dirForHocFile the Directory to getnerate into
     * @param addGrowthFunctions true if the extra functions, variables need to
     *        be added to allow growth of dends, etc.
     */
    public NeuronTemplateGenerator(Project project, Cell cell, File dirForHocFile, boolean addGrowthFunctions)
    {
        logger.logComment("HocTemplateGenerator created for: "+ CellTopologyHelper.printShortDetails(cell));
        this.cell = cell;
        this.project = project;

        StringBuffer spaceLessName = new StringBuffer();

        for (int i = 0; i < cell.getInstanceName().length(); i++)
        {
            char c = cell.getInstanceName().charAt(i);
            if ( c != ' ') spaceLessName.append(c);
        }
        hocFile = new File(dirForHocFile,  spaceLessName + ".hoc");

        this.addGrowthFunctions = addGrowthFunctions;

    }


    public String getHocFilename()
    {
        return this.hocFile.getAbsolutePath();
    }



    public String generateFile() throws NeuronException
    {
        logger.logComment("Starting generation of template file: "+hocFile);

        FileWriter fw = null;
        try
        {
            fw = new FileWriter(hocFile);

            fw.write("\n");
            fw.write(getHocFileHeader());
            fw.write("\nbegintemplate "+ cell.getInstanceName()+"\n\n");
            fw.write(this.getCommonHeader());
            fw.write(this.getHeaderForGroups());
            fw.write(this.getProcInit());
            fw.write(this.createSections());


            fw.write(this.getProcTopol());
            fw.write(this.getProcBasicShape());
            fw.write(this.getProcSubsets());
            fw.write(this.getProcGeom());
            fw.write(this.getProcGeomNseg());
            fw.write(this.getProcBiophys());
            fw.write(this.getProcPosition());
            fw.write(this.getProcConnect2target());
            ///////////fw.write(this.getProcSynapses());
            fw.write(this.getProcInfo());

            fw.write("\nendtemplate "+ cell.getInstanceName()+"\n\n");
            fw.flush();
            fw.close();
        }
        catch (Exception ex)
        {
            logger.logError("Error writing to file: " + hocFile, ex);
            try
            {
                fw.flush();
                fw.close();
            }
            catch (IOException ex1)
            {
            }
            throw new NeuronException("Error writing to file: " + hocFile);

        }

        return hocFile.getAbsolutePath();
    }


    private static String getHocFileHeader()
    {
        StringBuffer response = new StringBuffer();
        response.append("//  ******************************************************\n");
        response.append("//\n");
        response.append("//     File generated by: neuroConstruct v"+GeneralProperties.getVersionNumber()+"\n");
        response.append("//\n");
        response.append("//     Attempting to replicate hoc for Cell Type as exported \n");
        response.append("//     from NEURON's Cell Builder\n");
        response.append("//\n");
        response.append("//  ******************************************************\n");

        response.append("\n");
        return response.toString();
    }


    private String getCommonHeader()
    {
        logger.logComment("calling getCommonHeader");
        StringBuffer response = new StringBuffer();

        response.append("public init, topol, basic_shape, subsets, geom, memb\n");
        response.append("public synlist, x, y, z, position, connect2target\n\n");
        NeuronFileManager.addComment(response, "Some fields for referencing the cells");
        response.append("public reference, type, description, name\n");
        response.append("strdef reference, type, description, name\n\n");
        NeuronFileManager.addComment(response, "Some methods for referencing the cells");
        response.append("public toString, netInfo\n\n");



        if (addGrowthFunctions)
        {
            NeuronFileManager.addComment(response, " Needed for variable morphology\n");
            response.append("public add_dendritic_section, add_axonal_section\n");
            response.append("public additional_dends, additional_axons\n\n");
            response.append("public specify_num_extra_dends, specify_num_extra_axons\n\n");
        }

        response.append("public all\n\n");
        response.append("objref synlist\n");
        response.append("objref all\n");
        response.append("objref stringFuncs\n");


        response.append("\n");
        return response.toString();
    }

    private String getProcInit()
    {
        logger.logComment("calling getProcInit");
        StringBuffer response = new StringBuffer();
        response.append("proc init() {\n");

        if (addGrowthFunctions)
        {
            if (cell.getOnlyAxonalSegments().size() > 0)
            {
                response.append("create_dummy_axons()\n");
            }

            if (cell.getOnlyDendriticSegments().size() > 0)
            {
                response.append("create_dummy_dends()\n");
            }
        }

        response.append("    topol()\n");
        response.append("    subsets()\n");
        response.append("    geom()\n");
        response.append("    biophys()\n");
        response.append("    geom_nseg()\n");
        response.append("    synlist = new List()\n");
        /////////////response.append("    synapses()\n");
        response.append("    x = y = z = 0\n");


        //response.append("name = $s1\n");
        response.append("    reference = $s1\n");
        response.append("    type = $s2\n");
        response.append("    description = $s3\n");
        response.append("    \n");
        response.append("    strdef indexNum\n");
        response.append("    stringFuncs = new StringFunctions()\n");

        response.append("    stringFuncs.tail(reference, \"_\", indexNum)\n");

        response.append("    while (stringFuncs.substr( indexNum, \"_\")>=0) {\n");

        response.append("        stringFuncs.tail(indexNum, \"_\", indexNum)\n");

        response.append("    }\n");


        response.append("    \n");


        //response.append("    sprint(name, \"%s[%s]\", type, indexNum)\n");
        response.append("    sprint(name, \"%s\", type)\n");




        response.append("}\n");
        response.append("\n");
        return response.toString();
    }

    private String getProcInfo()
    {
        logger.logComment("calling getProcInfo");
        StringBuffer response = new StringBuffer();

        NeuronFileManager.addComment(response, "This function is useful in parallel networks when trying to locate cells...");
        response.append("proc toString() {\n");
        response.append("    strdef info\n");

        response.append("    sprint(info, \"Cell reference: %s (%s)\", reference, name)\n");

        response.append("    print info\n");


        response.append("}\n");
        response.append("\n");


        NeuronFileManager.addComment(response, "This function is useful when checking network connections");
        response.append("proc netInfo() {\n");


        response.append("    strdef info\n");

        response.append("    sprint(info, \"Cell reference: %s, type: %s\", reference, type)\n");

        response.append("    print \"--------  \",info\n");



        response.append("    print \"    There are \", synlist.count(), \" connections in \", synlist\n");

        response.append("    for i=0,synlist.count()-1 {\n");
        response.append("        print \"        Connection from \", synlist.o[i].precell, \" to: \", synlist.o[i].postcell\n");
        response.append("        print \"        Pre:   Weight: \", synlist.o[i].weight, \", delay: \", synlist.o[i].delay, \", threshold: \", synlist.o[i].threshold \n");
        response.append("        print \"        Post:  \", synlist.o[i].syn(), \", gmax: \", synlist.o[i].syn().gmax , \", e: \", synlist.o[i].syn().e , \", rise time: \", synlist.o[i].syn().tau1 , \", decay time: \", synlist.o[i].syn().tau2 \n");

        response.append("    print \" \"\n");
        response.append("    }\n");
        response.append("    \n");
        response.append("    \n");
        response.append("    \n");


        response.append("    print \"--------  \"\n");
        response.append("    print \" \"\n");


        response.append("}\n");
        response.append("\n");


        return response.toString();
    }






    private String createSections()
    {
        logger.logComment("creating Sections");
        StringBuffer response = new StringBuffer();

        ArrayList<Section> sections = cell.getAllSections();
        if (sections.size() > 0)
        {
            Hashtable<String, Integer> arraySectionsVsSize = new Hashtable<String, Integer>();

            for (int i = 0; i < sections.size(); i++)
            {
                Section next = (Section)sections.get(i);

                if (cell.getApPropSpeedForSection(next)==null)
                {
                    String name = NeuronFileManager.getHocSectionName(next.getSectionName());
                    System.out.println(name);

                    if (name.indexOf("[") > 0)
                    {
                        String arrayName = name.substring(0, name.indexOf("["));
                        Integer greatestIndexSoFar = (Integer) arraySectionsVsSize.get(arrayName);
                        int thisIndex
                            = Integer.parseInt(name.substring(name.indexOf("[") + 1,
                                                              name.indexOf("]")));

                        if (greatestIndexSoFar == null
                            || greatestIndexSoFar.intValue() < thisIndex)
                        {
                            arraySectionsVsSize.put(arrayName, thisIndex);
                        }
                    }
                    else
                    {
                        response.append("create " + name + "\n");
                        response.append("public " + name + "\n");
                    }
                }
            }
            Enumeration arrays = arraySectionsVsSize.keys();

            while (arrays.hasMoreElements())
            {
                String arr = (String)arrays.nextElement();
                logger.logComment("Looking at array: "+arr);
                Integer maxIndex = (Integer)arraySectionsVsSize.get(arr);
                response.append("create " + arr +"["+(maxIndex.intValue()+1)+"]"+ "\n");
                response.append("public " + arr + "\n");

            }
        }
        response.append("\n");


        return response.toString();
    }




    private String getProcTopol()
    {
        logger.logComment("calling getProcTopol");
        StringBuffer response = new StringBuffer();
        response.append("proc topol() {\n");

        Vector allConnectionLines =  getConnectLines();

        if (allConnectionLines.size()<maxNumLinesInProc)
        {
            logger.logComment("Only have "+allConnectionLines.size()+" connections, putting them in one function");

            for (int i = 0; i < allConnectionLines.size(); i++)
            {
                String nextLine = (String)allConnectionLines.elementAt(i);
                response.append(nextLine+"\n");
            }
            response.append("    basic_shape()\n");
            response.append("}\n");
            response.append("\n");

        }
        else
        {
            logger.logComment("Will have to split up the "+allConnectionLines.size()+" connections...");
            int numberToSplit = Math.round((float)allConnectionLines.size()/(float)maxNumLinesInProc) + 1;
            logger.logComment("Will create "+numberToSplit+" functions...");

            for (int i = 0; i < numberToSplit; i++)
            {
                response.append("    topol_extra_"+i+"()\n");
            }
            response.append("    basic_shape()\n");
            response.append("}\n");
            response.append("\n");

            for (int i = 0; i < numberToSplit; i++)
            {
                response.append("proc topol_extra_" + i + "(){\n");
                for (int j = 0; j < maxNumLinesInProc; j++)
                {
                    try
                    {
                        int index = (i*maxNumLinesInProc) + j;
                        String nextLine = (String) allConnectionLines.elementAt(index);
                        response.append(nextLine + "\n");
                    }
                    catch (Exception ex)
                    {
                        // no element, i.e. past the end of the array...
                    }
                }
                response.append("}\n");
                response.append("\n");
            }
        }



        return response.toString();
    }


    private Vector<String> getConnectLines()
    {
        Vector<String> connectLines = new Vector<String>();

        Vector segments = cell.getExplicitlyModelledSegments();

        logger.logComment("Investigating "+segments.size()+" segments...");


        for (int i = 0; i < segments.size(); i++)
        {
            Segment segment = (Segment)segments.elementAt(i);

            logger.logComment("Looking at segment number "+i+": "+segment);

            Segment parent = (Segment)segment.getParentSegment();

            logger.logComment("Parent of this is: "+parent);

            if (parent!=null &&
                segment.isFirstSectionSegment() &&
                !segment.getSection().equals(parent.getSection()))
            {
                //float distToConnectTo

                float fractionAlongParentSection =
                    CellTopologyHelper.getFractionAlongSection(cell,
                                                               segment.getParentSegment(),
                                                               segment.getFractionAlongParent());
                
                connectLines.add("    connect " + NeuronFileManager.getHocSectionName(segment.getSection().getSectionName())
                                 + "(0), "
                                 + NeuronFileManager.getHocSectionName(parent.getSection().getSectionName())
                                 + "("
                                 + fractionAlongParentSection
                                 + ")");
            }

        }
        return connectLines;
    }




    private String getProcBasicShape()
    {
        logger.logComment("--------------------------------calling getProcBasicShape");
        StringBuffer response = new StringBuffer();
        response.append("proc basic_shape() {\n");

        Vector allShapeLines = getShapeLines();


        if (allShapeLines.size() < maxNumLinesInProc)
        {
            logger.logComment("Only have " + allShapeLines.size() +" lines of shape info, putting them in one function");
            for (int i = 0; i < allShapeLines.size(); i++)
            {
                String nextLine = (String) allShapeLines.elementAt(i);
                response.append(nextLine + "\n");
            }
            response.append("}\n");
            response.append("\n");
        }
        else
        {
            logger.logComment("Will have to split up the " + allShapeLines.size() +" shape info lines...");
            int numberToSplit = Math.round( (float) allShapeLines.size() / (float) maxNumLinesInProc) +  1;
            logger.logComment("Will create " + numberToSplit + " functions...");

            for (int i = 0; i < numberToSplit; i++)
            {
                response.append("basic_shape_extra_" + i + "()\n");
            }
            response.append("}\n");
            response.append("\n");

            for (int i = 0; i < numberToSplit; i++)
            {
                response.append("proc basic_shape_extra_" + i + "(){\n");
                for (int j = 0; j < maxNumLinesInProc; j++)
                {
                    try
                    {
                        int index = (i * maxNumLinesInProc) + j;
                        String nextLine = (String) allShapeLines.elementAt(index);
                        response.append(nextLine + "\n");
                    }
                    catch (Exception ex)
                    {
                        // no element, i.e. past the end of the array...
                    }
                }
                response.append("}\n");
                response.append("\n");
            }
        }
        return response.toString();
    }


    /**
     * Returns a start point for the cylinder (i.e. section start point) which will
     * represent the spherical segment
     *
     */
    public static Point3f getSphericalSegmentStartPoint(Segment segment, Cell cell)
    {
        if (segment.getSegmentShape() != Segment.SPHERICAL_SHAPE)
        {
            logger.logError("Segment "+ segment+ " is not spherical");
            return null;
        }
        if (!cell.getAllSegments().contains(segment))
        {
            logger.logError("Segment "+ segment+ " is not part of cell: "+ cell);
            return null;
        }
        //Suggest a point along the z axis, the distance of the radius...

        Point3f proposedPoint = new Point3f(0,-1*segment.getRadius(),0);

        // For purely aesthetic purposes
       // Vector allSegs = cell.getAllSegments();
      //  for (int i = 0; i < allSegs.size(); i++)
      //  {
      //          Segment nextSeg = (Segment)allSegs.elementAt(i);
      //          if (nextSeg.getParentSegment()==)

     //   }
         return proposedPoint;

    }


    /**
     * Returns the end point for the cylinder (i.e. section end point) which will
     * represent the spherical segment
     *
     */
    public static Point3f getSphericalSegmentEndPoint(Segment segment, Cell cell)
    {
        if (segment.getSegmentShape() != Segment.SPHERICAL_SHAPE)
        {
            logger.logError("Segment "+ segment+ " is not spherical");
            return null;
        }
        if (!cell.getAllSegments().contains(segment))
        {
            logger.logError("Segment "+ segment+ " is part of cell: "+ cell);
            return null;
        }
        //Suggest a point along the z axis, the distance of the radius...

        Point3f proposedPoint = new Point3f(0,segment.getRadius(),0);

        // For purely aesthetic purposes
       // Vector allSegs = cell.getAllSegments();
      //  for (int i = 0; i < allSegs.size(); i++)
      //  {
      //          Segment nextSeg = (Segment)allSegs.elementAt(i);
      //          if (nextSeg.getParentSegment()==)

     //   }
         return proposedPoint;

    }



    private Vector getShapeLines()
    {
        Vector segments = cell.getExplicitlyModelledSegments();

        logger.logComment("Investigating " + segments.size() + " segments...");
        Vector<String> shapeLines = new Vector<String>();

        for (int i = 0; i < segments.size(); i++)
        {
            Segment segment = (Segment) segments.elementAt(i);
            Segment parent = (Segment)segment.getParentSegment();

            if (NeuronFileManager.addComments()) shapeLines.add("\n//  Looking at segment number " + i + ": "+ segment);

            if (segment.isSomaSegment() && segment.isFirstSectionSegment())
            {

                if (segment.getSegmentShape() == Segment.CYLINDRICAL_SHAPE)
                {
                    Point3f startPoint = segment.getSection().getStartPointPosition();
                    Point3f endPoint = segment.getEndPointPosition();


                    shapeLines.add("    "+NeuronFileManager.getHocSectionName(segment.getSection().getSectionName()) +" {pt3dclear() pt3dadd("
                                    + startPoint.x + ", "
                                    + startPoint.y + ", "
                                    + startPoint.z + ", "
                                    + (segment.getSection().getStartRadius() * 2)
                                    + ") pt3dadd("
                                    + endPoint.x + ", "
                                    + endPoint.y + ", "
                                    + endPoint.z + ", "
                                    + (segment.getRadius() * 2) + ")}");
                }
                else if (segment.getSegmentShape() == Segment.SPHERICAL_SHAPE)
                {
                    Point3f startPoint = getSphericalSegmentStartPoint(segment, cell);
                    Point3f endPoint = getSphericalSegmentEndPoint(segment, cell);

                    shapeLines.add("    "+NeuronFileManager.getHocSectionName(segment.getSection().getSectionName())
                                   + " {pt3dclear() pt3dadd("
                                   + startPoint.x + ", "
                                   + startPoint.y + ", "
                                   + startPoint.z + ", "
                                   + (segment.getRadius() * 2)
                                   + ") pt3dadd("
                                   + endPoint.x + ", "
                                   + endPoint.y + ", "
                                   + endPoint.z + ", "
                                   + (segment.getRadius() * 2) + ")}");
                }
            }
            else
            {
                if (parent.isSomaSegment()  &&
                    parent.isFirstSectionSegment() &&
                    parent.getSegmentShape() == Segment.SPHERICAL_SHAPE &&
                    !segment.isSomaSegment())
                {

                    shapeLines.add("    "+NeuronFileManager.getHocSectionName(segment.getSection().getSectionName()) + " {pt3dclear() pt3dadd(0,0,0,"
                                   + (segment.getRadius() * 2) + ") "
                                   + "pt3dadd("
                                   + segment.getEndPointPositionX() + ","
                                   + segment.getEndPointPositionY() + ","
                                   + segment.getEndPointPositionZ() + ", "
                                   + (segment.getRadius() * 2) + ")}");
                }
                else
                {
                    Point3f startPoint = null;
                    float startRadius = 0;

                    if (segment.isFirstSectionSegment())
                    {
                        startPoint = segment.getSection().getStartPointPosition();
                        startRadius = segment.getSection().getStartRadius();
                    }
                    else
                    {
                        startPoint = segment.getParentSegment().getEndPointPosition();
                        startRadius = segment.getParentSegment().getRadius();
                    }

                    StringBuffer lineToAdd = new StringBuffer("    "+NeuronFileManager.getHocSectionName(segment.getSection().getSectionName()) + " {");

                    if (segment.isFirstSectionSegment())
                    {
                        lineToAdd.append("pt3dclear() ");

                        lineToAdd.append("pt3dadd(" + startPoint.x + ","
                                         + startPoint.y + ","
                                         + startPoint.z + ", "
                                         + (startRadius * 2) + ") ");
                    }

                    lineToAdd.append("pt3dadd("
                                   + segment.getEndPointPositionX() + ","
                                   + segment.getEndPointPositionY() + ","
                                   + segment.getEndPointPositionZ() + ", "
                                   + (segment.getRadius() * 2) + ")}");


                    shapeLines.add(lineToAdd.toString());
                }
            }

        }
        return shapeLines;
    }



    private String getProcSubsets()
    {
        logger.logComment("---------  calling getProcSubsets");

        StringBuffer response = new StringBuffer();

        Vector<String> subsetLines = new Vector<String>();

        logger.logComment("Adding channel mechs for soma (etc)");

        Vector groupNames = cell.getAllGroupNames();

        for (int ii = 0; ii < groupNames.size(); ii++)
        {
            String groupName = (String) groupNames.elementAt(ii);
            if (!groupName.equals("all"))
            {
                logger.logComment("Found a group: " + groupName);

                subsetLines.add("    "+groupName + " = new SectionList()\n");

                /** @todo This could be cleaned up... */
                Vector allSegments = cell.getExplicitlyModelledSegments();

                for (int i = 0; i < allSegments.size(); i++)
                {
                    Segment segment = (Segment) allSegments.elementAt(i);
                    if (segment.isFirstSectionSegment())
                    {
                        if (segment.getGroups().contains(groupName))
                        {
                            subsetLines.add("    "+NeuronFileManager.getHocSectionName(segment.getSection().getSectionName()) + " " + groupName + ".append()");
                        }
                    }
                }
            }

            subsetLines.add("\n");

        }

        Vector segments = cell.getExplicitlyModelledSegments();

        for (int i = 0; i < segments.size(); i++)
        {
            Segment segment = (Segment) segments.elementAt(i);
            if (segment.isFirstSectionSegment())
            {
                subsetLines.add("    "+NeuronFileManager.getHocSectionName(segment.getSection().getSectionName()) + " all.append()");
            }

        }


        response.append("proc subsets() { local i\n");

        NeuronFileManager.addComment(response, "The group all is assumed never to change...\n");

        response.append("    "+"all = new SectionList()\n");

        //response.append("soma all.append()\n");
        //if (cell.getOnlyAxonalSegments().size() > 0) response.append("for i=0, nAxons axon[i] all.append()\n");
        //if (cell.getOnlyDendriticSegments().size() > 0) response.append("for i=0, nDendrites dend[i] all.append()\n\n");






        if (subsetLines.size() < maxNumLinesInProc)
        {
            logger.logComment("..............     Only have " + subsetLines.size() +
                              " lines of subset info, putting them in one function");
            for (int i = 0; i < subsetLines.size(); i++)
            {
                String nextLine = (String) subsetLines.elementAt(i);
                response.append(nextLine+"\n");
            }
            response.append("}\n");
            response.append("\n");
        }
        else
        {
            logger.logComment("Will have to split up the " + subsetLines.size() + " subset info lines...");
            int numberToSplit = Math.round( (float) subsetLines.size() / (float) maxNumLinesInProc) + 1;
            logger.logComment("Will create " + numberToSplit + " functions...");

            for (int i = 0; i < numberToSplit; i++)
            {
                response.append("subsets_extra_" + i + "()\n");
            }
            response.append("}\n");
            response.append("\n");

            for (int i = 0; i < numberToSplit; i++)
            {
                response.append("proc subsets_extra_" + i + "(){\n");
                for (int j = 0; j < maxNumLinesInProc; j++)
                {
                    try
                    {
                        int index = (i * maxNumLinesInProc) + j;
                        String nextLine = (String) subsetLines.elementAt(index);
                        response.append(nextLine + "\n");
                    }
                    catch (Exception ex)
                    {
                        // no element, i.e. past the end of the array...
                    }
                }
                response.append("}\n");
                response.append("\n");
            }
            }

        logger.logComment("---------  finished getProcSubsets");

        return response.toString();
    }


    private String getHeaderForGroups()
    {
        logger.logComment("calling getHeaderForGroups");

        StringBuffer response = new StringBuffer();

        Vector groupNames = cell.getAllGroupNames();
        for (int ii = 0; ii < groupNames.size(); ii++)
        {
            String groupName = (String)groupNames.elementAt(ii);
            if (!groupName.equals("all"))
            {
                response.append("public " + groupName + "\n");
                response.append("objref " + groupName + "\n");
            }
        }
        response.append("\n");
        return response.toString();
    }



    private String getProcGeom()
    {
        logger.logComment("calling getProcGeom");
        StringBuffer response = new StringBuffer();
        response.append("proc geom() {\n");
/*
        Soma soma = cell.getSomaDetails();
        response.append("soma {  L = "+soma.getLength()+"  diam = "+soma.getDiameter()+"  }\n");

        Axon axon = cell.getAxonDetails();
        response.append("axon {  L = "+axon.getLength()+"  diam = "+axon.getDiameter()+"  }\n");

        Dendrite[] dendrites = cell.getDendrites();
        for (int i = 0; i < dendrites.length; i++)
        {
            response.append("dend["+i+"] {  L = "+dendrites[i].getLength()+" diam = "+dendrites[i].getDiameter()+"  }\n");
        }

            */
        response.append("}\n");
        response.append("\n");
        return response.toString();
    }

    /*
    private String getProcCreateDummyAxons()
    {
        logger.logComment("calling getProcCreateDummyAxons");
        StringBuffer response = new StringBuffer();
        response.append("proc create_dummy_axons() {\n");
        NeuronFileManager.addComment(response, " This procedure is needed as we have to define additional_axons[] etc\n");
        NeuronFileManager.addComment(response, "as an array (of one element), and we don't want the default section values\n");

        response.append("additional_axons[0] {pt3dclear() pt3dadd(0, 0, 0, 0.1) pt3dadd(0, 0, 0.1, 0.1)}\n");
        response.append("additional_axons[0] { nseg = 1 }\n");
        response.append("}\n");
        response.append("\n");
        return response.toString();
    }

    private String getProcCreateDummyDends()
    {
        logger.logComment("calling getProcCreateDummyDends");
        StringBuffer response = new StringBuffer();
        response.append("proc create_dummy_dends() {\n");
        NeuronFileManager.addComment(response, " This procedure is needed as we have to define additional_dends[] etc\n");
        NeuronFileManager.addComment(response, "as an array (of one element), and we don't want the default section values\n");

        response.append("additional_dends[0] {pt3dclear() pt3dadd(0, 0, 0, 0.1) pt3dadd(0, 0, 0.1, 0.1)}\n");
        response.append("additional_dends[0] { nseg = 1 }\n");
        response.append("}\n");
        response.append("\n");
        return response.toString();
    }


    private String getProcSpecifyNumExtraDends()
    {
        logger.logComment("calling getProcSpecifyNumExtraDends");
        StringBuffer response = new StringBuffer();
        response.append("proc specify_num_extra_dends() {\n");
        response.append("num = $1\n");
        response.append("nMaxAdditionalDendrites = num\n");
        response.append("print \"Number of extra dendritic sections set at \", num\n");
        response.append("create additional_dends[num]\n");
        response.append("}\n");
        response.append("\n");
        return response.toString();
}

    private String getProcSpecifyNumExtraAxons()
    {
        logger.logComment("calling getProcSpecifyNumExtraAxons");
        StringBuffer response = new StringBuffer();
        response.append("proc specify_num_extra_axons() {\n");
        response.append("num = $1\n");
        response.append("nMaxAdditionalAxons = num\n");
     //   response.append("print \"Number of extra axonal sections set at \", num\n");
        response.append("create additional_axons[num]\n");
        response.append("}\n");
        response.append("\n");
        return response.toString();
    }



        private String getFuncAddDendSection()
        {
            logger.logComment("calling getFuncAddDendSection");
            StringBuffer response = new StringBuffer();
            response.append("func add_dendritic_section() {\n");
            response.append(" \n");

   //////         response.append("print \"Adding another dendritic section...\"\n");

            response.append("parentSection = $1\n");
            response.append("whereToAdd = $2\n");
            response.append("x_endpoint = $3\n");
            response.append("y_endpoint = $4\n");
            response.append("z_endpoint = $5\n");


           // response.append("print \"Going to append new section to dendrite number \", parentSection, \", at distance along: \", whereToAdd\n");
    ////        response.append("print \"End point will be at: (\", x_endpoint, \", \", y_endpoint, \", \", z_endpoint, \")\"\n");
    ////        response.append("print \"There are already \", nAdditionalDendrites, \" additional sections here, of a max: \", nMaxAdditionalDendrites\n");
            response.append("additional_dends[nAdditionalDendrites] insert pas\n");
            response.append("connect additional_dends[nAdditionalDendrites](0), dend[parentSection](whereToAdd)\n");
            response.append("additional_dends[nAdditionalDendrites] {pt3dclear() pt3dadd(0, 0, 0, dend[parentSection].diam) pt3dadd(x_endpoint,y_endpoint,z_endpoint, dend[parentSection].diam)}\n");
            response.append("additional_dends[nAdditionalDendrites] all.append()\n\n");

            response.append("nAdditionalDendrites = nAdditionalDendrites +1\n");

            response.append("return nAdditionalDendrites\n");

            response.append("}\n");
            response.append("\n");
            return response.toString();
        }




        private String getFuncAddAxonSection()
        {
            logger.logComment("calling getFuncAddAxonSection");
            StringBuffer response = new StringBuffer();
            response.append("func add_axonal_section() {\n");
            response.append(" \n");

      ///      response.append("print \"Adding another axonal section...\"\n");

            response.append("parentSection = $1\n");
            response.append("whereToAdd = $2\n");
            response.append("x_endpoint = $3\n");
            response.append("y_endpoint = $4\n");
            response.append("z_endpoint = $5\n");


       //     response.append("print \"Going to append new section to axon number \", parentSection, \", at distance along: \", whereToAdd\n");
        ///    response.append("print \"End point will be at: (\", x_endpoint, \", \", y_endpoint, \", \", z_endpoint, \")\"\n");
        ///    response.append("print \"There are already \", nAdditionalAxons, \" additional sections here, of a max: \", nMaxAdditionalAxons\n");
            response.append("additional_axons[nAdditionalAxons] insert pas\n");
            response.append("connect additional_axons[nAdditionalAxons](0), axon[parentSection](whereToAdd)\n");
            response.append("additional_axons[nAdditionalAxons] {pt3dclear() pt3dadd(0, 0, 0, axon[parentSection].diam) pt3dadd(x_endpoint,y_endpoint,z_endpoint, axon[parentSection].diam)}\n");
            response.append("additional_axons[nAdditionalAxons] all.append()\n\n");

            response.append("nAdditionalAxons = nAdditionalAxons +1\n");

            response.append("return nAdditionalAxons\n");

            response.append("}\n");
            response.append("\n");
            return response.toString();
        }
*/


    private String getProcGeomNseg()
    {
        logger.logComment("calling getProcGeomNseg");
        StringBuffer response = new StringBuffer();
        //response.append("//external lambda_f\n");


        Vector<String> nsegLines = new Vector<String>();

        Vector allSegments = cell.getExplicitlyModelledSegments();
        
        for (int i = 0; i < allSegments.size(); i++)
        {
            Segment segment = (Segment) allSegments.elementAt(i);
            if (segment.isFirstSectionSegment())
            {

                    nsegLines.add("    "+NeuronFileManager.getHocSectionName(segment.getSection().getSectionName())
                                    + " nseg = "
                                    + segment.getSection().getNumberInternalDivisions());

            }
        }
        response.append("proc geom_nseg() {\n");

        if (nsegLines.size() < maxNumLinesInProc)
        {
            logger.logComment("..............     Only have " + nsegLines.size() +
                              " nsegLines, putting them in one function");

            for (int i = 0; i < nsegLines.size(); i++)
            {
                String nextLine = (String) nsegLines.elementAt(i);
                response.append(nextLine + "\n");
            }
            response.append("}\n");
            response.append("\n");
        }
        else
        {
            logger.logComment("Will have to split up the " + nsegLines.size() + " nsegLines...");

            int numberToSplit = Math.round( (float) nsegLines.size() / (float) maxNumLinesInProc) + 1;
            logger.logComment("Will create " + numberToSplit + " functions...");

            for (int i = 0; i < numberToSplit; i++)
            {
                response.append("geom_nseg_extra_" + i + "()\n");
            }
            response.append("}\n");
            response.append("\n");

            for (int i = 0; i < numberToSplit; i++)
            {
                response.append("proc geom_nseg_extra_" + i + "(){\n");
                for (int j = 0; j < maxNumLinesInProc; j++)
                {
                    try
                    {
                        int index = (i * maxNumLinesInProc) + j;
                        String nextLine = (String) nsegLines.elementAt(index);
                        response.append(nextLine + "\n");
                    }
                    catch (Exception ex)
                    {
                        // no element, i.e. past the end of the array...
                    }
                }
                response.append("}\n");
                response.append("\n");
            }
            }

        response.append("\n");
        return response.toString();
    }


    private String getProcBiophys()
    {
        logger.logComment("calling getProcBiophys");
        StringBuffer response = new StringBuffer();
        response.append("proc biophys() {\n");


        Vector<String> groupNames = cell.getAllGroupNames();

        for (String nextGroup: groupNames)
        {
            float specCap = cell.getSpecCapForGroup(nextGroup);
            if (!Float.isNaN(specCap))
            {
                response.append("    forsec " + nextGroup + " cm = "
                                + UnitConverter.getSpecificCapacitance(specCap,
                                                                       UnitConverter.NEUROCONSTRUCT_UNITS,
                                                                       UnitConverter.NEURON_UNITS)
                                + "\n");
            }
            float specAxRes = cell.getSpecAxResForGroup(nextGroup);
            if (!Float.isNaN(specAxRes))
            {
                response.append("    forsec " + nextGroup + " Ra = " +
                                UnitConverter.getSpecificAxialResistance(specAxRes,
                                                                         UnitConverter.NEUROCONSTRUCT_UNITS,
                                                                         UnitConverter.NEURON_UNITS)
                                + "\n");
            }
        }
        response.append("\n");


        if (cell.getChanMechsVsGroups().size()>100)
        {

            response.append("    addChanMechs()\n");
            response.append("}\n\n");
            response.append("proc addChanMechs() {\n\n");
        }

        for (String nextGroup: groupNames)
        {
            ArrayList<ChannelMechanism> allChanMechs = cell.getChanMechsForGroup(nextGroup);

            if (allChanMechs.size()>0)
            {

                for (int j = 0; j < allChanMechs.size(); j++)
                {

                    ChannelMechanism nextChanMech = allChanMechs.get(j);

                    CellMechanism cellMech = project.cellMechanismInfo.getCellMechanism(nextChanMech.getName());

                    boolean requiresXYZ = false;

                    try
                    {
                        requiresXYZ = cellMech instanceof AbstractedCellMechanism &&
                            ( (AbstractedCellMechanism) cellMech).parameterExists("RequiresXYZ") &&
                            ( (AbstractedCellMechanism) cellMech).getParameter("RequiresXYZ") == 1;
                    }
                    catch (CellMechanismException ex1)
                    {
                        logger.logComment("No param RequiresXYZ...");
                    }


                    response.append("    forsec " + nextGroup + " { ");

                    NeuronFileManager.addComment(response,
                                                 "    Assuming parameters other than max cond dens are set in the mod file...");
                    response.append("        insert " + nextChanMech.getName() + "");

                    double condDens = UnitConverter.getConductanceDensity(nextChanMech.getDensity(),
                                                                          UnitConverter.NEUROCONSTRUCT_UNITS,
                                                                          UnitConverter.NEURON_UNITS);
                    
                    if (cellMech.getMechanismType().equals(DistMembraneMechanism.CHANNEL_MECHANISM))
                    {

                        response.append("  { gmax_" + nextChanMech.getName() + " = " + condDens + " }  ");
                    }

                    if (cellMech instanceof ChannelMLCellMechanism)
                    {
                        //float revPotential = Float.NaN;
                        //NeuronFileManager.addHocFileComment(response, "This Cell Process is based on a ChannelML file");

                        ChannelMLCellMechanism cmlProc = (ChannelMLCellMechanism) cellMech;

                        //cmlProc
                        String xpath = ChannelMLConstants.getIonsXPath();

                        logger.logComment("Checking xpath: " + xpath);

                        SimpleXMLEntity[] ions = null;
                        try
                        {

                            cmlProc.initialise(project, false); // just in case...

                            ions = cmlProc.getXMLDoc().getXMLEntities(xpath);
                        }
                        catch (ChannelMLException ex)
                        {
                            GuiUtils.showErrorMessage(logger,
                                                      "Error getting information from ChannelML process: "
                                                      + cmlProc.getInstanceName(), ex, null);

                            return "Error in generation: " + ex.getMessage();
                        }

                        if (ions != null && ions.length > 0)
                        {
                            for (int i = 0; i < ions.length; i++)
                            {
                                SimpleXMLElement ion = (SimpleXMLElement) ions[i];
                                logger.logComment("Got ion: " + ion.getXMLString("", false));

                                NeuronFileManager.addComment(response, "    Ion "
                                                             + ion.getAttributeValue(ChannelMLConstants.ION_NAME_ATTR)
                                                             + " is used in this process...");

                                if (! (ion.getAttributeValue(ChannelMLConstants.ION_NAME_ATTR)
                                       .equals(ChannelMLConstants.NON_SPECIFIC_ION_NAME)))
                                {
                                    String erev = ion.getAttributeValue(ChannelMLConstants.ION_REVERSAL_POTENTIAL_ATTR);

                                    logger.logComment("Setting erev: " + erev);
                                    if (erev != null)
                                    {

                                        String unitsUsed = cmlProc.getUnitsUsedInFile();

                                        logger.logComment("Units used = " + unitsUsed);

                                        if (unitsUsed != null)
                                        {
                                            double suggValDouble = Double.parseDouble(erev);

                                            if (unitsUsed.equals(ChannelMLConstants.SI_UNITS))
                                            {
                                                suggValDouble = UnitConverter.getVoltage(suggValDouble,
                                                    UnitConverter.GENESIS_SI_UNITS,
                                                    UnitConverter.NEUROCONSTRUCT_UNITS);
                                            }
                                            else if (unitsUsed.equals(ChannelMLConstants.PHYSIOLOGICAL_UNITS))
                                            {
                                                suggValDouble = UnitConverter.getVoltage(suggValDouble,
                                                    UnitConverter.GENESIS_PHYSIOLOGICAL_UNITS,
                                                    UnitConverter.NEUROCONSTRUCT_UNITS);
                                            }

                                            erev = suggValDouble + "";
                                        }

                                        response.append("        e" + ion.getAttributeValue(ChannelMLConstants.ION_NAME_ATTR)
                                                        + " = " + erev + "\n");
                                    }
                                    else
                                    {
                                        NeuronFileManager.addComment(response,
                                                                     "Note: there is no reversal potential present for ion: "
                                                                     + ion.getAttributeValue(ChannelMLConstants.ION_NAME_ATTR));
                                    }
                                }
                                else
                                {
                                    logger.logComment("That's a non specific process...");
                                }
                            }
                        }

                    }

                    response.append("    }\n\n");


                    if (requiresXYZ)
                    {
                        NeuronFileManager.addComment(response, "Need to add x,y,z coords for this mechanism...");

                        ArrayList<Section> secs = cell.getSectionsInGroup(nextGroup);
                        for (Section sec: secs)
                        {
                            Point3f midpoint = CellTopologyHelper.convertSectionDisplacement(cell, sec, 0.5f);
                            response.append("    "+NeuronFileManager.getHocSectionName(sec.getSectionName())+".x_"+nextChanMech.getName()+" = "+midpoint.x+"\n");
                            response.append("    "+NeuronFileManager.getHocSectionName(sec.getSectionName())+".y_"+nextChanMech.getName()+" = "+midpoint.y+"\n");
                            response.append("    "+NeuronFileManager.getHocSectionName(sec.getSectionName())+".z_"+nextChanMech.getName()+" = "+midpoint.z+"\n\n");
                        }
                    }


                    //}
                }
            }




        }

        response.append("}\n");
        response.append("\n");
        return response.toString();
    }


    private String getProcPosition()
    {
        logger.logComment("calling getProcPosition");
        StringBuffer response = new StringBuffer();

        response.append("proc position() { local i\n");


        response.append("    forsec all {\n");
        response.append("        for i = 0, n3d()-1 {\n");
        
        response.append("            pt3dchange(i, $1+x3d(i), $2+y3d(i), $3+z3d(i), diam3d(i))\n");
        response.append("        }\n");        
        response.append("    }\n");
        response.append("    //x = $1  y = $2  z = $3\n");
        response.append("}\n");

        response.append("\n");
        return response.toString();
    }




    private String getProcConnect2target()
    {
        logger.logComment("calling getProcConnect2target");
        StringBuffer response = new StringBuffer();
        response.append("proc connect2target() {   //$o1 target point process, $o2 returned NetCon\n\n");

         NeuronFileManager.addComment(response, "Using standard NetBuilder form. (Overly) simple assumption that first soma seg is trigger for AP.../n");

        response.append("    "+NeuronFileManager.getHocSectionName(cell.getFirstSomaSegment().getSection().getSectionName())
                +" $o2 = new NetCon(&v(1), $o1)\n");

        response.append("}\n");
        response.append("\n");
        return response.toString();
    }



/*
    private String getProcSynapses()
    {
        logger.logComment("calling getProcSynapses");
        StringBuffer response = new StringBuffer();
        response.append("proc synapses() {\n");

        response.append("//  Nothing for now...\n");
        response.append("}\n");
        response.append("\n");
        return response.toString();
    }*/




    public static void main(String[] args)
    {
        try
        {
            Project testProj = Project.loadProject(new File("models/BioMorph/BioMorph.neuro.xml"),
                                                   new ProjectEventListener()
            {
                public void tableDataModelUpdated(String tableModelName)
                {};

                public void tabUpdated(String tabName)
                {};
                public void cellMechanismUpdated()
                {
                };

            });

            //SimpleCell cell = new SimpleCell("DummyCell");
            //ComplexCell cell = new ComplexCell("DummyCell");

            Cell cell = testProj.cellManager.getCell("LongCellDelayLine");

            //File f = new File("/home/padraig/temp/tempNC/NEURON/PatTest/basics/");
            File f = new File("../temp");

            NeuronTemplateGenerator cellTemplateGenerator1 = new NeuronTemplateGenerator(testProj, cell,
                f, false);

            System.out.println("Generated: " + cellTemplateGenerator1.generateFile());
            System.out.println(CellTopologyHelper.printDetails(cell, null));
        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
    }

}
