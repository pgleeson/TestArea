/**
 * neuroConstruct
 *
 * Software for developing large scale 3D networks of biologically realistic neurons
 * Copyright (c) 2007 Padraig Gleeson
 * UCL Department of Physiology
 *
 * Development of this software was made possible with funding from the
 * Medical Research Council
 *
 */

package ucl.physiol.neuroconstruct.nmodleditor.modfile;

import java.io.*;
import java.util.*;
import java.awt.*;

import ucl.physiol.neuroconstruct.utils.*;
import ucl.physiol.neuroconstruct.nmodleditor.processes.*;
import ucl.physiol.neuroconstruct.nmodleditor.gui.*;

/**
 * nmodlEditor application software. The main class representing a *.mod file
 *
 * @author Padraig Gleeson
 * @version 1.0.3
 */

public class ModFile implements ModFileChangeListener
{
    ClassLogger logger = new ClassLogger("ModFile");

    public static final int FILE_NOT_EDITED = 0;
    public static final int FILE_EDITED_NOT_SAVED = 1;
    public static final int FILE_SAVED = 2;

    private int myStatus;
    public File myCurrentFile;

    private Vector myElements = new Vector();

    private TitleElement titleElement = new TitleElement();// empty...

    public NeuronElement myNeuronElement = new NeuronElement(this);
    public UnitsElement myUnitsElement = new UnitsElement(this);
    public AssignedElement myAssignedElement = new AssignedElement(this);
    public StateElement myStateElement = new StateElement(this);
    public ParametersElement myParametersElement = new ParametersElement(this);
    public InitialElement myInitialElement = new InitialElement(this);
    public BreakpointElement myBreakpointElement = new BreakpointElement(this);
    public DerivativeElement myDerivativeElement = new DerivativeElement(this);
    public NetReceiveElement myNetReceiveElement = new NetReceiveElement(this);



    private ModFile()
    {

    }

    /**
     * Constructor when loading an existing mod file
     * @param filename full path of the file to load
     * @throws ModFileException if the file does not exist
     */
    public ModFile(String filename) throws ModFileException
    {
        logger.setThisClassSilent(true);

        logger.logComment("Creating new ModFile object from file: "+ filename);
        myCurrentFile = new File(filename);

        if (!myCurrentFile.exists())
        {
            throw new ModFileException("The mod file "
                                       + myCurrentFile.getAbsolutePath()
                                       + " does not exist!");
        }

        myElements.add(titleElement); // always first (could be empty)...
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));

        parseFile();

        myStatus = FILE_NOT_EDITED;
    }


    /**
     * Constructor for creating a new *.mod file
     * @param fullFilename full path of the file to create
     * @param processName The main process as described by the NMODL file
     * @param processType Either NeuronElement.POINT_PROCESS or NeuronElement.DENSITY_MECHANISM
     * @throws ModFileException if there is a problem creating the file
     */
    public ModFile(String fullFilename, String processName, int processType) throws ModFileException
    {
        logger.logComment("Creating new ModFile object with filename: "+ fullFilename);
        myCurrentFile = new File(fullFilename);

        logger.logComment("Already exists?: "+ myCurrentFile.exists());

        myNeuronElement = new NeuronElement(this);

        if (processType==NeuronElement.POINT_PROCESS)
        {
            myNeuronElement.addLine("POINT_PROCESS "+ processName);
        }
        else if (processType==NeuronElement.DENSITY_MECHANISM)
        {
            myNeuronElement.addLine("SUFFIX "+ processName);
        }


        titleElement.setTitle(this.getFileName()+": Generated by neuroConstruct\n");
        myElements.add(titleElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        myElements.add(myNeuronElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        myElements.add(myUnitsElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        myElements.add(myParametersElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        myElements.add(myAssignedElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        myElements.add(myStateElement);
        /*
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        myElements.add(myInitialElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        myElements.add(myBreakpointElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        myElements.add(myDerivativeElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        myElements.add(myNetReceiveElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        */

        logger.logComment("Content of neuron block: "+ myNeuronElement);

        myStatus = FILE_EDITED_NOT_SAVED;
    }


    public void modFileElementChanged(String modFileElementType)
    {
        logger.logComment("modFileElementChanged called by: "+ modFileElementType);
        this.myStatus = FILE_EDITED_NOT_SAVED;
    }

    public void modFileChanged()
    {
        logger.logComment("modFileChanged called");
        this.myStatus = FILE_EDITED_NOT_SAVED;
    }


    public String getFileName()
    {
        return myCurrentFile.getName();
    }

    public String getFullFileName()
    {
        return myCurrentFile.getAbsolutePath();
    }

    public File getCurrentFile()
    {
        return myCurrentFile;
    }


    public void saveToFile() throws ModFileException
    {
        logger.logComment("Saving the file...");

        try
        {
            FileWriter fw = new FileWriter(myCurrentFile);
            fw.write(getFileContentsAsString());
            fw.close();
        }
        catch (IOException ex)
        {
            throw new ModFileException("Error saving file: "+ myCurrentFile.getAbsolutePath(), ex);
        }
        myStatus = FILE_SAVED;
    }

    public void saveAs(String filename) throws ModFileException
    {
        this.myCurrentFile = new File(filename);

        saveToFile();
    }

    public int getStatus()
    {
        return myStatus;

    }

    /**
     * Parse the file and extract the elements from the text
     * @throws ModFileException if there is an error in the parsing
     */
    private void parseFile() throws ModFileException
    {
        logger.logComment("+++++++++++++++++++++++  Parsing file: "+ myCurrentFile.getAbsolutePath());

        if(!myCurrentFile.exists())
        {
            throw new ModFileException("The file "+ myCurrentFile.getAbsolutePath() + " does not exist!");
        }

        try
        {
            Reader in = new FileReader(myCurrentFile);
            BufferedReader lineReader = new BufferedReader(in);
            String nextLine = null;

            // As an empty line is produced by the toString of the Elements
            int lineNumber = 0;

            while ( (nextLine = lineReader.readLine()) != null)
            {
                lineNumber++;

                logger.logComment("Looking at line number: "+lineNumber+" (" + nextLine+")");
                // Note: don't trim yet, to preserve line tabulation in functions etc.

                if (nextLine.trim().length() == 0)
                {
                    logger.logComment(">>  Empty line...");

                    SimpleModFileElement emptyLineElement = new SimpleModFileElement("EMPTY_LINE", " \n");
                    myElements.add(emptyLineElement);
                }
                else
                {
                    if (nextLine.trim().startsWith(":") || nextLine.trim().startsWith("?"))
                    {
                        logger.logComment(">>  Comment line...");
                        SimpleModFileElement commentElement = new SimpleModFileElement("COMMENT_LINE", nextLine + "\n");
                        myElements.add(commentElement);

                    }

                    else if (nextLine.trim().startsWith("TITLE "))
                    {
                        logger.logComment(">>  Title line...");
                        try
                        {
                            this.titleElement.setTitle(nextLine.trim().substring("TITLE ".length())+ "\n");
                            if (!myElements.contains(titleElement)) myElements.add(titleElement);
                        }
                        catch (StringIndexOutOfBoundsException ex)
                        {
                            // no title present...
                        }
                    }


                    else if (nextLine.trim().startsWith("LOCAL "))
                    {
                        logger.logComment(">>  LOCAL variable line...");
                        try
                        {
                            LocalElement localElement = new LocalElement(nextLine.trim().substring("LOCAL ".length())+ "\n");
                            myElements.add(localElement);
                        }
                        catch (StringIndexOutOfBoundsException ex)
                        {
                            // no local vars present...
                        }
                    }

                    else if (nextLine.trim().startsWith("INDEPENDENT"))
                    {
                        logger.logComment(">>  INDEPENDENT variable line...");
                        try
                        {
                            IndependentElement indElement = new IndependentElement(nextLine.substring(nextLine.indexOf("{")+1, nextLine.indexOf("}")).trim());
                            myElements.add(indElement);
                        }
                        catch (StringIndexOutOfBoundsException ex)
                        {
                            // no local vars present...
                        }
                    }

                    else if (nextLine.trim().equals("UNITSON"))
                    {
                        logger.logComment(">>  UNITSON line...");

                        SimpleModFileElement unitsonElement = new SimpleModFileElement("UNITSON", nextLine);
                        myElements.add(unitsonElement);

                    }

                    else if (nextLine.trim().equals("UNITSOFF"))
                    {
                        logger.logComment(">>  UNITSOFF line...");

                        SimpleModFileElement unitsoffElement = new SimpleModFileElement("UNITSOFF", nextLine);
                        myElements.add(unitsoffElement);

                    }



                    else if (nextLine.indexOf("{")>0
                             && nextLine.indexOf("}")<0
                             || nextLine.trim().equals("COMMENT")
                             || nextLine.trim().equals("VERBATIM"))
                    {
                        logger.logComment("Found a probable new multi line element...");
                        String elementName = null;

                        if (nextLine.trim().equals("COMMENT")) elementName = "COMMENT";
                        else if (nextLine.trim().equals("VERBATIM")) elementName = "VERBATIM";
                        else
                        {
                            nextLine = nextLine.trim();
                            int firstWhiteSpace = Integer.MAX_VALUE;
                            for (int i = 0; i < nextLine.length(); i++)
                            {
                                if (Character.isWhitespace(nextLine.charAt(i)))
                                {
                                    if (i<firstWhiteSpace) firstWhiteSpace = i;
                                }
                            }

                            int firstBracket = nextLine.indexOf("(");
                            if (firstBracket>0&&firstBracket<firstWhiteSpace)
                                elementName = nextLine.substring(0, firstBracket);
                            else
                                elementName = nextLine.substring(0, firstWhiteSpace);
                        }


                        logger.logComment("Decided on the new element type: "+ elementName);

                        ModFileBlockElement newElement = getElementBasedOnType(elementName);


                        try
                        {
                            FunctionElement functionElement = (FunctionElement) newElement;
                            String functionName = nextLine.substring(nextLine.indexOf(" "), nextLine.indexOf("(")).trim();
                            String parameters = nextLine.substring(nextLine.indexOf("("), nextLine.indexOf("{")).trim();
                            functionElement.initialise(functionName, parameters);
                        }
                        catch (ClassCastException ex1)
                        {
                            // just continue...
                        }

                        try
                        {
                            ProcedureElement procedureElement = (ProcedureElement) newElement;
                            String procedureName = nextLine.substring(nextLine.indexOf(" "), nextLine.indexOf("(")).trim();
                            String parameters = nextLine.substring(nextLine.indexOf("("), nextLine.indexOf("{")).trim();
                            procedureElement.initialise(procedureName, parameters);
                        }
                        catch (ClassCastException ex1)
                        {
                            // just continue...
                        }

                        try
                        {
                            DerivativeElement derivativeElement = (DerivativeElement) newElement;
                            String name = nextLine.substring(nextLine.indexOf(" "), nextLine.indexOf("{")).trim();
                            derivativeElement.initialise(name);
                        }
                        catch (ClassCastException ex1)
                        {
                            // just continue...
                        }

                        try
                        {
                            NetReceiveElement netReceiveElement = (NetReceiveElement) newElement;

                            String params = nextLine.substring("NET_RECEIVE".length(), nextLine.indexOf("{")).trim();
                            logger.logComment("NetReceiveElement found. params: "+params);

                            netReceiveElement.initialise(params);
                        }
                        catch (ClassCastException ex1)
                        {
                            // just continue...
                        }

                        // Now lets go through the inside of the block...

                        boolean insideElement = true;
                        int depthOfBrackets = 0;
                        logger.logComment("----  Going inside block: "+newElement.getType());
                        while (insideElement)
                        {
                            nextLine = lineReader.readLine();
                            lineNumber++;
                            if (nextLine == null)
                            {
                                throw new ModFileException("Reached end of file before end of element: "+ elementName);
                            }

                            logger.logComment("Looking at line number: "+lineNumber+": (" + nextLine+") as part of element: "+ elementName);

                            for (int i = 0; i < nextLine.length(); i++)
                            {
                                if (nextLine.charAt(i)=='{') depthOfBrackets++;
                                if (nextLine.charAt(i)=='}') depthOfBrackets--;
                            }
                            logger.logComment("Depth of brackets: "+depthOfBrackets);

                            if (nextLine.trim().equals(newElement.getBlockEndingString()))
                            {
                                logger.logComment("New line is BlockEndingString: "+ newElement.getBlockEndingString());

                                if (!newElement.getBlockEndingString().equals("}")) // i.e. as in the case of ENDCOMMENT
                                {
                                    logger.logComment("End of element...");
                                    insideElement = false;
                                }
                                else
                                {
                                    if (depthOfBrackets==-1)
                                    {
                                        insideElement = false; // i.e. went through all brackets, including the closing one at the end
                                    }
                                    else newElement.addLine(nextLine); // in the case where the brackets from the function haven't ended, but a single closing bracket is on a line on it's own
                                }
                            }
                            else  newElement.addLine(nextLine);
                        } // end of while (insideElement)

                        logger.logComment("----  Finished block: "+newElement.getType());

                    }
                    else if (nextLine.indexOf("{")>0 && nextLine.indexOf("}")>0)
                    {
                        String elementName = nextLine.substring(0, nextLine.indexOf(" "));
                        logger.logComment("Found a probable one line new element named: "+ elementName);

                        ModFileBlockElement newElement = getElementBasedOnType(elementName);
                        String lineContent = nextLine.substring(nextLine.indexOf("{")+1, nextLine.indexOf("}"));
                        lineContent = lineContent.trim();

                        newElement.addLine(lineContent);

                    }
                    else
                    {
                        throw new ModFileException("Problem parsing line number "+lineNumber+": "+ nextLine);
                    }
                }

            }
        }
        catch (IOException ex)
        {
            throw new ModFileException("Error parsing file: "+ myCurrentFile.getAbsolutePath(), ex);
        }

        if(myNeuronElement.getProcessName()==null)
        {
            throw new ModFileException("There does not seem to have been a NEURON element in that file!!");
        }

        logger.logComment("+++++++++++++++++++++++  Finished parsing file: "+ myCurrentFile.getAbsolutePath());


    }

    public ModFileBlockElement getElementBasedOnType(String elementType) throws ModFileException
    {
        logger.logComment("Checking element: --"+elementType+"--");
        if (elementType.equals("NEURON"))
        {
            myElements.add(myNeuronElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return myNeuronElement;
        }
        else if (elementType.equals("UNITS"))
        {
            myElements.add(myUnitsElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return myUnitsElement;
        }
        else if (elementType.equals("COMMENT"))
        {
            CommentElement newCommentElement = new CommentElement(this);
            myElements.add(newCommentElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return newCommentElement;
        }

        else if (elementType.equals("VERBATIM"))
        {
            VerbatimElement newVerbatimElement = new VerbatimElement(this);
            myElements.add(newVerbatimElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return newVerbatimElement;
        }

        else if (elementType.equals("STATE"))
        {
            myElements.add(myStateElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return myStateElement;
        }
        else if (elementType.equals("ASSIGNED"))
        {
            myElements.add(myAssignedElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return myAssignedElement;
        }
        else if (elementType.equals("PARAMETER"))
        {
            myElements.add(myParametersElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return myParametersElement;
        }
        else if (elementType.equals("INITIAL"))
        {
            myElements.add(myInitialElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return myInitialElement;
        }
        else if (elementType.equals("BREAKPOINT"))
        {
            myElements.add(myBreakpointElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return myBreakpointElement;
        }
        else if (elementType.equals("FUNCTION"))
        {
            FunctionElement newFunctionElement = new FunctionElement(this);
            myElements.add(newFunctionElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return newFunctionElement;
        }
        else if (elementType.equals("PROCEDURE"))
        {
            ProcedureElement newProcedureElement = new ProcedureElement(this);
            myElements.add(newProcedureElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));

            return newProcedureElement;
        }

        else if (elementType.equals("DERIVATIVE"))
        {
            myElements.add(myDerivativeElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return myDerivativeElement;
        }

        else if (elementType.equals("NET_RECEIVE"))
        {
            logger.logComment("It's a NET_RECEIVE");
            myElements.add(myNetReceiveElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
            return myNetReceiveElement;
        }

        else if (elementType.equals("KINETIC") ||
                 elementType.equals("FUNCTION_TABLE"))
        {
            throw new ModFileException("That block is not supported in the current version of NMODL Editor: "+elementType);
        }



        else return new GenericModFileElement(elementType, this);
    }

    public void printInternalInfo()
    {
        boolean previousPrintoutState = logger.getThisClassSilent();
        if (previousPrintoutState) logger.setThisClassSilent(false);

        logger.logComment("-------------------------------------------------------------------");
        logger.logComment("ModFile: "+ myCurrentFile.getAbsolutePath());
        logger.logComment("Status: "+ getStatus());

        int numOfElements = myElements.size();

        logger.logComment("Currently has "+numOfElements+" elements:");


        for (int i = 0; i < myElements.size(); i++)
        {
            SimpleModFileElement element = (SimpleModFileElement)myElements.elementAt(i);
            logger.logComment("-------------------   Element "+i+": "+ element.getType());
            logger.logComment(element.toString());
        }
        logger.logComment("-------------------------------------------------------------------");
        if (previousPrintoutState) logger.setThisClassSilent(true);
    }


    public String getFileContentsAsString()
    {
        logger.logComment("Converting document to string...");
        StringBuffer sb = new StringBuffer();

        int numOfElements = myElements.size();

        logger.logComment("Adding "+numOfElements+" elements");

        Iterator elements = myElements.iterator();
        SimpleModFileElement lastFullElement = null;
        while (elements.hasNext())
        {
            SimpleModFileElement element = (SimpleModFileElement)elements.next();

            String elementAsString = element.toString();
            StringBuffer shortenedElement = new StringBuffer();
            if (elementAsString!=null)
            {
                if (elementAsString.length() < 12)
                {
                    shortenedElement.append(elementAsString);
                }
                else
                {
                    shortenedElement.append(elementAsString.substring(0, 12) + "...");
                }
                shortenedElement.append(" (number of lines: " + elementAsString.split("\\n").length + ")");
            }
            else shortenedElement.append("null");



            logger.logComment("Element: "+ element.getType() + ": "+ shortenedElement);
            if (elementAsString!=null)
            {
                if (lastFullElement !=null
                    && lastFullElement.getType().equals("EMPTY_LINE")
                    && element.getType().equals("EMPTY_LINE"))
                {
                    logger.logComment("Ignoring repeated empty line...");
                }
                else
                {
                    logger.logComment("Adding that line");
                    sb.append(elementAsString);
                }
                lastFullElement = element;
            }
        }


        return sb.toString();
    }

    public void testFileWithNeuron() throws ModFileException
    {
        ProcessManager testProcess = new ProcessManager(myCurrentFile);
        testProcess.testFileWithNeuron();
    }

    public boolean compileModFile() throws ModFileException
    {
        ProcessManager compileProcess = new ProcessManager(myCurrentFile);
        logger.logComment("Trying to compile the file: "+myCurrentFile.getAbsoluteFile()+" which has parent: "+myCurrentFile.getParent());
        boolean success = compileProcess.compileFileWithNeuron();

        logger.logComment("Compiled hoc file...");

        return success;

    }

    public void generateTestHocFile() throws ModFileException
    {
        logger.logComment("Trying to create a test hoc file...");

        String testFilename = "Test_" + myCurrentFile.getName().replace('.', '_') + ".hoc";

        File testFile = new File(myCurrentFile.getParent()
                                 + System.getProperty("file.separator")
                                 + testFilename);

        HocSettingsDialog dlg
            = new HocSettingsDialog("Simulation settings",
                                    testFile,
                                    myNeuronElement,
                                    myParametersElement.getParameters());



        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        Dimension frameSize = dlg.getSize();

        dlg.setLocation((screenSize.width - frameSize.width) / 2,
                        (screenSize.height - frameSize.height) / 2);
        dlg.pack();
        dlg.setVisible(true);

        if (dlg.wasCancelled )
        {
            logger.logComment("User cancelled action");
            return;
        }

    }

    public Vector getFunctions()
    {
        Vector allFunctions = new Vector();
        for (int i = 0; i < myElements.size(); i++)
        {
            try
            {
                FunctionElement functionElement = (FunctionElement) myElements.elementAt(i);
                allFunctions.add(functionElement);
            }
            catch (ClassCastException ex1)
            {
                // just continue...
            }
        }
        return allFunctions;
    }

    public boolean removeFunction(FunctionElement fe)
    {
        boolean success = myElements.remove(fe);
        return success;
    }


    public void addNewFunction(String functionName) throws ModFileException
    {
        for (int i = 0; i < myElements.size(); i++)
        {
            FunctionElement nextElement = null;
            try
            {
                nextElement = (FunctionElement) myElements.elementAt(i);
                if (nextElement.myFunctionName.equals(functionName))
                {
                    throw new ModFileException("That function name is already in use");
                }
            }
            catch (ClassCastException ex)
            {
            }
        }
        FunctionElement functionElement = new FunctionElement(this);
        functionElement.initialise(functionName, "");
        myElements.add(functionElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));

    }

    public Vector getProcedures()
    {
        Vector allProcedures = new Vector();
        for (int i = 0; i < myElements.size(); i++)
        {
            try
            {
                ProcedureElement procedureElement = (ProcedureElement) myElements.elementAt(i);
                allProcedures.add(procedureElement);
            }
            catch (ClassCastException ex1)
            {
                // just continue...
            }
        }
        return allProcedures;
    }

    public boolean removeProcedure(ProcedureElement pe)
    {
        boolean success = myElements.remove(pe);
        return success;
    }


    public void addNewProcedure(String procedureName) throws ModFileException
    {
        for (int i = 0; i < myElements.size(); i++)
        {
            ProcedureElement nextElement = null;
            try
            {
                nextElement = (ProcedureElement) myElements.elementAt(i);
                if (nextElement.myProcedureName.equals(procedureName))
                {
                    throw new ModFileException("That procedure name is already in use");
                }
            }
            catch (ClassCastException ex)
            {
            }
        }
        ProcedureElement procedureElement = new ProcedureElement(this);
        procedureElement.initialise(procedureName, "");
        myElements.add(procedureElement);
        myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));

    }

    public String toString()
    {
        if (this.titleElement.toString()==null
            || titleElement.toString().trim().length()==0)
        {

            return myNeuronElement.getProcessName();
        }
        else
            return myNeuronElement.getProcessName() + " ("+ titleElement.getTitle() + ")";
    }



    public String getTitle()
    {
        logger.logComment("getTitle called");
        return titleElement.getTitle();
    }

    public void setTitle(String title)
    {
        logger.logComment("setTitle called");
        myStatus = FILE_EDITED_NOT_SAVED;
        titleElement.setTitle(title+ "\n");
    }


    public void ensureDerivativeBlockInElements()
    {
        if (!myElements.contains(this.myDerivativeElement))
        {
            myElements.add(myDerivativeElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        }
    }


    public void ensureInitialBlockInElements()
    {
        if (!myElements.contains(this.myInitialElement))
        {
            myElements.add(myInitialElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        }
    }


    public void ensureNetReceiveBlockInElements()
    {
        if (!myElements.contains(this.myNetReceiveElement))
        {
            myElements.add(myNetReceiveElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        }
    }


    public void ensureBreakpointBlockInElements()
    {
        if (!myElements.contains(this.myBreakpointElement))
        {
            myElements.add(myBreakpointElement);
            myElements.add(new SimpleModFileElement("EMPTY_LINE", "\n"));
        }
    }





}
