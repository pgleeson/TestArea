//  ******************************************************
// 
//     File generated by: neuroConstruct v1.5.3
// 
//  ******************************************************

{load_file("nrngui.hoc")}

//  Initialising stopwatch for timing setup

{startsw()}

print ""
print "*****************************************************"
print ""
print "    neuroConstruct generated NEURON simulation "
print "    for project: /Users/danielruedt/nC_projects/LarkumEtAl2009_local/LarkumEtAl2009_local.ncx "
print ""
print "    Description: CELL TYPES:"
print "    "
print "    LarkumPyr_imported is the NeuroML file generated by NEURON"
print "    "
print "    "
print "    LarkumPyr_CML is the model where the original NEURON mechanisms have been replaced by the corresponding ChannelML description (whenever possible)."
print "    "
print "    "
print "    SIMULATION CONFIGURATIONS:"
print "    "
print "    Default Simulation Configuration: compares the ChannelML channels with the original NEURON files"
print "    "
print "    CMLtest_pyr: compares the behaviour of the pyramidal neuron with all the channels inserted (CML vs NEURON implementation)"
print "    "
print "    CaSpike (Schiller et al 1997): attempts to trigger a Ca spike via a current injection in apical hot zone (the Ca spike always produces a somatic AP)"
print "    "
print "    BACfiring (Larkum et al. 1999): reproduces the nonlinear interaction between somatic AP and apical depolarization"
print "    "
print "    Synchronous Distributed Syn: 150 synapses (0.5AMPA/1NMDA) randomly distributed on the all apical tree are able to trigger an AP (via multiple NMDA spikes + Ca spike, according to Larkum et al. 2009)"
print "    "
print "    NMDAspike input: a paired pulse (20ms) delivered from 30 synchronous synapses on a single apical branch triggers an NMDA spike (as in Larkum et. 2009)"
print "    "
print "    -------------"
print "    Aug 2010"
print "    "
print "    Erev set via neuroConstruct to 50mV for Na and -87mV for K (according to Larkum et al 2009 supplementary informations)"
print "    "
print "    Reported problem of Neuron 7 with tables: when the external parameter vshift  is changed the tables are not updated and the NeuroML model behaves differently from Neuron 6.2"
print ""
print "    Simulation Configuration: SimConfig: CaSpike "
print "    Trigger a Ca2+ spike via an apical current injection (as in Schiller et al 1997)."
print "    "
print "    However to a Calcium spike always follow a somatic AP. "
print " "
print  "*****************************************************"

strdef pwd
{system("pwd", pwd)}
print ""
print "Current working dir: ", pwd

objectvar allCells
{allCells = new List()}


//  A flag to signal simulation was generated by neuroConstruct 

{nC = 1}


//  Including neuroConstruct utilities file 

{load_file("nCtools.hoc")}

//  Including neuroConstruct cell check file 

{load_file("cellCheck.hoc")}

//  Getting hostname

objref strFuncs
{strFuncs = new StringFunctions()}
strdef host
{system("hostname", host)}
if (strFuncs.len(host)>0) {
    strFuncs.left(host, strFuncs.len(host)-1) 
} else {
    host = "????" 
}


//  Simulation running in serial mode, setting default host id

{hostid = 0}


//  Initializes random-number generator

{use_mcell_ran4(1)}

{mcell_ran4_init(271356508)}


//////////////////////////////////////////////////////////////////////
//   Cell group 2: pyr_group has cells of type: LarkumPyr
//////////////////////////////////////////////////////////////////////


//  Adding cell template file: LarkumPyr.hoc for cell group pyr_group

{ load_file("LarkumPyr.hoc") }

//  Adding 1 cells of type LarkumPyr in region pyr_region

{n_pyr_group = 1}

{n_pyr_group_local = 0 } // actual number created on this host

objectvar a_pyr_group[n_pyr_group]

proc addCell_pyr_group() {
    strdef reference
    sprint(reference, "pyr_group_%d", $1)
    a_pyr_group[$1] = new LarkumPyr(reference, "LarkumPyr", "Cell: soma exported from NEURON ModelView")
    allCells.append(a_pyr_group[$1])
}

for i = 0, n_pyr_group-1 {
    addCell_pyr_group(i)
    n_pyr_group_local = n_pyr_group_local +1 

}


//  Placing these cells in a region described by: Rectangular Box from point: (0.0, 0.0, 0.0) to (50.0, 50.0, 50.0)


//  Packing has been generated by: Random: num: 1, edge: 1, overlap: 1, other overlap: 1

{a_pyr_group[0].position(30.54148,42.020123,12.568381)}




//////////////////////////////////////////////////////////////////////
//   Setting initial parameters
//////////////////////////////////////////////////////////////////////

strdef simConfig
{simConfig = "CaSpike"}
{celsius = 34.0}


//      Note: the following values are from IonProperties in Cell



proc initialiseValues0() {


//  Setting initial vals in cell group: pyr_group which has 1 cells


//  Giving all cells an initial potential of: -60.0

    for i = 0, n_pyr_group-1 {
        forsec a_pyr_group[i].all  v = -60.0

    }

}

objref fih0
{fih0 = new FInitializeHandler(0, "initialiseValues0()")}


proc initialiseValues1() {

    for i = 0, n_pyr_group-1 {
        forsec a_pyr_group[i].allCell { ek = -87.0}
        forsec a_pyr_group[i].all { ena = 50.0}
    }

}

objref fih1
{fih1 = new FInitializeHandler(1, "initialiseValues1()")}



//////////////////////////////////////////////////////////////////////
//   Adding Network Connections
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//   Adding 1 stimulation(s)
//////////////////////////////////////////////////////////////////////

{ n_stim_IClamp_CaSpike = 1 }
objectvar stim_IClamp_CaSpike[n_stim_IClamp_CaSpike]


//  Note: the stimulation was specified as being at a point 0.318182 along segment: Seg0_apic_40

//  in section: apic_40. For NEURON, this translates to a point 0.0056892587 along section: apic_40

access LarkumPyr[0].apic_58

stim_IClamp_CaSpike[0] = new CurrentClampExt(0.318182)
stim_IClamp_CaSpike[0].del = 50.0
stim_IClamp_CaSpike[0].dur = 400.0
stim_IClamp_CaSpike[0].amp = 1.0
stim_IClamp_CaSpike[0].repeat = 0



access LarkumPyr[0].soma

//////////////////////////////////////////////////////////////////////
//   Settings for running the demo
//////////////////////////////////////////////////////////////////////


tstop = 500.0
dt = 0.025
steps_per_ms = 40.0

//////////////////////////////////////////////////////////////////////
//   Adding 3 plot(s)
//////////////////////////////////////////////////////////////////////


//   This code pops up a plot of a_pyr_group[0].apic_59.v(0.99722964)

objref LV_pyr_group_v
LV_pyr_group_v = new Graph(0)
{LV_pyr_group_v.size(0, tstop,-90.0,50.0)}
{LV_pyr_group_v.view(0, -90.0, tstop, 140.0, 80, 330, 330, 250)}
{
    LV_pyr_group_v.addexpr("a_pyr_group[0].apic_59.v", "a_pyr_group[0].apic_59.v(1)", 1, 1, 0.8, 0.9, 2)
    graphList[0].append(LV_pyr_group_v)
}

//   This code pops up a plot of a_pyr_group[0].apic_11.v(0.14164168)

{
    LV_pyr_group_v.addexpr("a_pyr_group[0].apic_11.v", "a_pyr_group[0].apic_11.v(0.5)", 2, 1, 0.8, 0.9, 2)
    graphList[0].append(LV_pyr_group_v)
}

//   This code pops up a plot of a_pyr_group[0].apic_58.v(0.5)

{
    LV_pyr_group_v.addexpr("a_pyr_group[0].apic_58.v", "a_pyr_group[0].apic_58.v(0.5)", 2, 1, 0.8, 0.9, 2)
    graphList[0].append(LV_pyr_group_v)
}

//   This code pops up a plot of a_pyr_group[0].soma.v(0.024999956)

{
    LV_pyr_group_v.addexpr("a_pyr_group[0].soma.v", "a_pyr_group[0].soma.v(0.5)", 3, 1, 0.8, 0.9, 2)
    graphList[0].append(LV_pyr_group_v)
}

//////////////////////////////////////////////////////////////////////
//   Adding blocks of native NEURON code
//////////////////////////////////////////////////////////////////////


//  Hoc commands to run at location: Type 1, After Cell Process mechanism INITIAL blocks

objref fih_1
fih_1 = new FInitializeHandler(1.0, "callfi1()")
proc callfi1() {
forall Ra=85

}

//  End of hoc commands to run at location: Type 1, After Cell Process mechanism INITIAL blocks


//////////////////////////////////////////////////////////////////////
//   This will run a full simulation of 20001 steps when the hoc file is executed
//////////////////////////////////////////////////////////////////////


//  Recording 3 variable(s)

objref v_time
objref f_time
objref propsFile

v_time = new Vector()
{ v_time.record(&t) }
{ v_time.resize(80001) }
f_time = new File()


//  Saving VOLTAGE on only one seg, id: 8608, in the only cell in pyr_group


//  Creating vector for segment: Seg130_apic_59(ID: 8608)

objref v_pyr_group_seg_Seg130_apic_59_v[1]
for i=0, 0 {
    { v_pyr_group_seg_Seg130_apic_59_v[i] = new Vector() }
    { v_pyr_group_seg_Seg130_apic_59_v[i].record(&LarkumPyr[0].apic_59.v(1))} 
    { v_pyr_group_seg_Seg130_apic_59_v[i].resize(80001) }
}
objref f_pyr_group_seg_Seg130_apic_59_v[1]


//  Saving VOLTAGE on only one seg, id: 3884, in the only cell in pyr_group


//  Creating vector for segment: Seg0_apic_11(ID: 3884)

objref v_pyr_group_seg_Seg0_apic_11_v[1]
for i=0, 0 {
    { v_pyr_group_seg_Seg0_apic_11_v[i] = new Vector() }
    { v_pyr_group_seg_Seg0_apic_11_v[i].record(&LarkumPyr[0].apic_11.v(0.5))} 
    { v_pyr_group_seg_Seg0_apic_11_v[i].resize(80001) }
}
objref f_pyr_group_seg_Seg0_apic_11_v[1]


//  Saving VOLTAGE on only one seg


//  Creating vector for segment: Seg0_apic_58

objref v_pyr_group_seg_Seg0_apic_58_v[1]
for i=0, 0 {
    { v_pyr_group_seg_Seg0_apic_58_v[i] = new Vector() }
    { v_pyr_group_seg_Seg0_apic_58_v[i].record(&LarkumPyr[0].apic_58.v(0.5))} 
    { v_pyr_group_seg_Seg0_apic_58_v[i].resize(80001) }
}
objref f_pyr_group_seg_Seg0_apic_58_v[1]

//  Saving VOLTAGE on only one seg, id: 0, in the only cell in pyr_group


//  Creating vector for segment: Seg0_soma(ID: 0)

objref v_pyr_group_seg_Seg0_soma_v[1]
for i=0, 0 {
    { v_pyr_group_seg_Seg0_soma_v[i] = new Vector() }
    { v_pyr_group_seg_Seg0_soma_v[i].record(&LarkumPyr[0].soma.v(0.5))} 
    { v_pyr_group_seg_Seg0_soma_v[i].resize(80001) }
}
objref f_pyr_group_seg_Seg0_soma_v[1]

strdef simReference
simReference = ""



strdef simsDir
simsDir = ""


//  Note: to change location of the generated simulation files, just change value of targetDir
//  e.g. targetDir="" or targetDir="aSubDir/"

strdef targetDir
{ sprint(targetDir, "%s%s", simsDir, simReference)}


//  Single simulation run...


//  Hoc commands to run at location: Type -0.5, After network created


access LarkumPyr[0].soma
objref output_times, netcon, nil
output_times = new Vector()
netcon = new NetCon(&v(.5), nil, -20, 0, 1)
netcon.record(output_times)


// DR addition for recording spiketimes



//  End of hoc commands to run at location: Type -0.5, After network created

strdef date
// Note: not showing date/time of start/stop of simulation. This requires Cygwin to be installed// which includes the "date" unix command. Install under c:\cygwin

setuptime = stopsw()

print "Setup time for simulation: ",setuptime," seconds"

print "Starting simulation of duration ",tstop,"ms, dt: ",dt,"ms, reference: ",simReference,""

{currenttime = startsw()}
//////////////////////////////////////////////////////////////////////
//   Main run statement
//////////////////////////////////////////////////////////////////////

{run()}

{realruntime = startsw() - currenttime}
print "Finished simulation in ", realruntime ,"seconds"

print "Storing the data..."

strdef timeFilename

//  Saving VOLTAGE on only one seg, id: 8608, in the only cell in pyr_group


//  Saving vector for segment: Seg130_apic_59(ID: 8608)

for i=0, 0 {
    f_pyr_group_seg_Seg130_apic_59_v[i] = new File()
    strdef filename
    {sprint(filename, "%spyr_group_%d.8608.dat", targetDir, i)}
    f_pyr_group_seg_Seg130_apic_59_v[i].wopen(filename)
    v_pyr_group_seg_Seg130_apic_59_v[i].printf(f_pyr_group_seg_Seg130_apic_59_v[i])
    f_pyr_group_seg_Seg130_apic_59_v[i].close()
}


//  Saving VOLTAGE on only one seg, id: 3884, in the only cell in pyr_group


//  Saving vector for segment: Seg0_apic_11(ID: 3884)

for i=0, 0 {
    f_pyr_group_seg_Seg0_apic_11_v[i] = new File()
    strdef filename
    {sprint(filename, "%spyr_group_%d.3884.dat", targetDir, i)}
    f_pyr_group_seg_Seg0_apic_11_v[i].wopen(filename)
    v_pyr_group_seg_Seg0_apic_11_v[i].printf(f_pyr_group_seg_Seg0_apic_11_v[i])
    f_pyr_group_seg_Seg0_apic_11_v[i].close()
}


//  Saving VOLTAGE on only one seg


//  Saving vector for segment: Seg0_apic_58

for i=0, 0 {
    f_pyr_group_seg_Seg0_apic_58_v[i] = new File()
    strdef filename
    {sprint(filename, "%spyr_group_%d.apic58.dat", targetDir, i)}
    f_pyr_group_seg_Seg0_apic_58_v[i].wopen(filename)
    v_pyr_group_seg_Seg0_apic_58_v[i].printf(f_pyr_group_seg_Seg0_apic_58_v[i])
    f_pyr_group_seg_Seg0_apic_58_v[i].close()
}

//  Saving VOLTAGE on only one seg, id: 0, in the only cell in pyr_group


//  Saving vector for segment: Seg0_soma(ID: 0)

for i=0, 0 {
    f_pyr_group_seg_Seg0_soma_v[i] = new File()
    strdef filename
    {sprint(filename, "%spyr_group_%d.dat", targetDir, i)}
    f_pyr_group_seg_Seg0_soma_v[i].wopen(filename)
    v_pyr_group_seg_Seg0_soma_v[i].printf(f_pyr_group_seg_Seg0_soma_v[i])
    f_pyr_group_seg_Seg0_soma_v[i].close()
}


{ sprint(timeFilename, "%s%s", targetDir, "time.dat")}
{ f_time.wopen(timeFilename) }
{ v_time.printf(f_time) }
{ f_time.close() }

{savetime = stopsw()}

propsFile = new File()
strdef propsFilename
{sprint(propsFilename, "%ssimulator.props", targetDir)}
{propsFile.wopen(propsFilename)}
{propsFile.printf("#This is a list of properties generated by NEURON during the simulation run\n")}
{propsFile.printf("Host=%s\n", host)}
{propsFile.printf("RealSimulationTime=%g\n", realruntime)}
{propsFile.printf("SimulationSaveTime=%g\n", savetime)}
{propsFile.printf("SimulationSetupTime=%g\n", setuptime)}
{propsFile.printf("NEURONversion=%s\n", nrnversion())}
{propsFile.close()}

print "Data stored in ",savetime, "secs in directory: ", targetDir


//   This code pops up a simple Run Control

{
xpanel("RunControl", 0)
v_init = -70.0
xbutton("Init & Run","run()")
xbutton("Stop","stoprun=1")
t = 0
xvalue("t","t", 2 )
tstop = 500.0
xvalue("Tstop","tstop", 1,"tstop_changed()", 0, 1 )
dt = 0.025
 xvalue("dt","dt", 1,"setdt()", 0, 1 )
xpanel(80,80)
}


//  Hoc commands to run at location: Type 10, After simulation run

objref output
output = new File()
output.wopen("output_times_dt0.025.dat")
output_times.printf(output)
output.close()



//  End of hoc commands to run at location: Type 10, After simulation run

